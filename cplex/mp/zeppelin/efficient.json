{"info": {}, "config": {"looknfeel": "default", "personalizedMode": "false"}, "name": "C:\\Users\\AURELIEFolacci\\python\\workspace\\docplex\\docplex\\src\\samples\\examples\\delivery\\jupyter\\efficient", "paragraphs": [{"settings": {"forms": {}, "params": {}}, "text": "%md\n# Writing efficient DOcplex code\n\nIn this notebook, we show how to improve efficiency of DOcplex models using five simple rules.", "apps": [], "results": {"msg": [{"data": "<h1>Writing efficient DOcplex code</h1>\n<p></p>\n<p>In this notebook, we show how to improve efficiency of DOcplex models using five simple rules.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## A simple timing tool\n\nTo measure performance we need a simple timing tool. For this purpose, we chose to implement a Python context manager object (see https://docs.python.org/3/reference/datamodel.html#context-managers) for details.\n\nThis object stores the start time when entering a block and reports time spent when exiting the block. Python's `with` statement avoids cluttering code with intrusive prints.", "apps": [], "results": {"msg": [{"data": "<h2>A simple timing tool</h2>\n<p></p>\n<p>To measure performance we need a simple timing tool. For this purpose, we chose to implement a Python context manager object (see https://docs.python.org/3/reference/datamodel.html#context-managers) for details.</p>\n<p></p>\n<p>This object stores the start time when entering a block and reports time spent when exiting the block. Python's <code>with</code> statement avoids cluttering code with intrusive prints.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\nimport time\nimport math\n\nclass ContextTimer(object):\n    def __init__(self, msg):\n        self.msg = msg\n        self.start = 0\n        \n    def __enter__(self):\n        self.start = time.time()\n        return self  # return value is value of with ()\n        \n    def __exit__(self, *args):\n        elapsed = time.time() - self.start\n        self.msecs = math.ceil(1000* elapsed)\n        print('<-- {0},  time: {1:.0f} ms'.format(self.msg, self.msecs))   \n        \n# try our timer on computing fibonacci numbers\n\ndef fib(n):\n    return 1 if n <= 2 else  fib(n-1) + fib(n-2)\n\n# timing fibonacci(30)\nwith ContextTimer(\"fibonacci 30\"):\n    n = 30\n    f = fib(n)\n    print(\"fibonacci({0}) = {1}\".format(n, f))\n        ", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## The benchmark model\n\nTo compare various implementations, we need a simple, scalable benchmark model. The model has no real business meaning, but is simple to grasp\nand can be scaled by changing one `size` parameter.\nNote that we'll be comparing only the _build_ time of the model, not the _solve_ time.\n\nNote that the model has _n_ constraints, all with expressions of size _N_, so we expect the underlying matrix _size_ to grow as $O(N^2)$.", "apps": [], "results": {"msg": [{"data": "<h2>The benchmark model</h2>\n<p></p>\n<p>To compare various implementations, we need a simple, scalable benchmark model. The model has no real business meaning, but is simple to grasp</p>\n<p>and can be scaled by changing one <code>size</code> parameter.</p>\n<p>Note that we'll be comparing only the <em>build</em> time of the model, not the <em>solve</em> time.</p>\n<p></p>\n<p>Note that the model has <em>n</em> constraints, all with expressions of size <em>N</em>, so we expect the underlying matrix <em>size</em> to grow as $O(N^2)$.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n### Description\n\nLet $N$ be an integer (the size of the problem).\n\n$$\nminimize \\sum_{k=0}^{k=N-1} (k+1) * y_{k}\\\\\ns.t.\\\\\n\\forall\\ \\ m\\ in \\{0..N-1\\}\\ \\ \\sum_{l=0}^{l=N-1} (y_{l} * (l+ (l+m) \\%3) \\ge l\\\\\ny_{k} = 0, 1\n$$", "apps": [], "results": {"msg": [{"data": "<h3>Description</h3>\n<p></p>\n<p>Let $N$ be an integer (the size of the problem).</p>\n<p></p>\n<p>$$</p>\n<p>minimize \\sum<em>{k=0}^{k=N-1} (k+1) * y</em>{k}\\</p>\n<p>s.t.\\</p>\n<p>\\forall\\ \\ m\\ in {0..N-1}\\ \\ \\sum<em>{l=0}^{l=N-1} (y</em>{l} * (l+ (l+m) \\%3) \\ge l\\</p>\n<p>y_{k} = 0, 1</p>\n<p>$$</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## A beginners's implementation of the model\n\nIn this section we show a Python/Docplex beginner's implementation of this model.\n", "apps": [], "results": {"msg": [{"data": "<h2>A beginners's implementation of the model</h2>\n<p></p>\n<p>In this section we show a Python/Docplex beginner's implementation of this model.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\nfrom docplex.mp.model import Model\n\ndef build_bench_model1(size=10):\n    m = Model(name=\"bench1\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_dict(rsize, name=\"y\")\n    # create constraints\n    k = {(i,j) : (i + (i+j) %3) for i in rsize for j in rsize}\n    for i in rsize:\n        m.add(m.sum(ys[i] * k[i,j] for j in rsize) >= i, \"ct_%d\" %i)\n    # for minimize, create a list of coefficients\n    rsize1 = [i+1 for i in rsize]\n    m.minimize(m.sum(ys[k] * rsize[k] for k in rsize))\n    return m", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\nLets run our context timer with N=1000; we expect a model with 1000 variables and 1000 constraints:", "apps": [], "results": {"msg": [{"data": "<p>Lets run our context timer with N=1000; we expect a model with 1000 variables and 1000 constraints:</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\nwith ContextTimer(\"bench1_size_1000\"):\n    m11k = build_bench_model1(1000)\n    m11k.print_information()", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\nAs expected the model has 1000 variables and 1000 constraints and the build time is significant.\nFor N=3000, we can expect an increase in buid time by a factor of 9:", "apps": [], "results": {"msg": [{"data": "<p>As expected the model has 1000 variables and 1000 constraints and the build time is significant.</p>\n<p>For N=3000, we can expect an increase in buid time by a factor of 9:</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\nN=3000\nwith ContextTimer(\"bench1 size={0}\".format(N)):\n    build_bench_model1(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n# Seven tips to improve DOcplex code efficiency", "apps": [], "results": {"msg": [{"data": "<h1>Seven tips to improve DOcplex code efficiency</h1>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Use scalar product\n\nWhen building large expressions,  scalar product (`Model.scal_prod()`) is \nan efficient way to combine a sequence of variables (or expressions)\nand a sequence of coefficients.\nTry using `scalar_prod` instead of using `for` loops in expressions.", "apps": [], "results": {"msg": [{"data": "<h2>Use scalar product</h2>\n<p></p>\n<p>When building large expressions,  scalar product (<code>Model.scal_prod()</code>) is </p>\n<p>an efficient way to combine a sequence of variables (or expressions)</p>\n<p>and a sequence of coefficients.</p>\n<p>Try using <code>scalar_prod</code> instead of using <code>for</code> loops in expressions.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model2(size=10):\n    m = Model(name=\"bench2\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_dict(rsize, name=\"y\")\n    # create constraints\n    k = {(i,j) : (i + (i+j) %3) for i in rsize for j in rsize}\n    for i in rsize:\n        m.add(m.scal_prod([ys[i1] for i1 in rsize], [k[i,j] for j in rsize]) >= i, \"ct_%d\" % i)\n    # for minimize, create a list of coefficients\n    rsize1 = [i+1 for i in rsize]\n    m.minimize(m.scal_prod([ys[k] for k in rsize], rsize1))\n    return m\n\nwith ContextTimer(\"bench3 size={0}\".format(N)):\n    build_bench_model2(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n### Use variable lists instead of dicts, if possible\n\nIn the previous examples, we had to create an auxiliary sequence from the variable dictionary to pass to `scal_prod`. Actually, a variable _list_ would be much simpler to use than the dictionary, so we replace the `var_dict` by a `var_list`", "apps": [], "results": {"msg": [{"data": "<h3>Use variable lists instead of dicts, if possible</h3>\n<p></p>\n<p>In the previous examples, we had to create an auxiliary sequence from the variable dictionary to pass to <code>scal_prod</code>. Actually, a variable <em>list</em> would be much simpler to use than the dictionary, so we replace the <code>var_dict</code> by a <code>var_list</code></p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model21(size=10):\n    m = Model(name=\"bench2.1\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    k = {(i,j) : (i + (i+j) %3) for i in rsize for j in rsize}\n    for i in rsize:\n        m.add(m.scal_prod(ys, [k[i,j] for j in rsize]) >= i, \"ct_%d\" % i)\n    # for minimize, create a list of coefficients\n    rsize1 = [i+1 for i in rsize]\n    m.minimize(m.scal_prod(ys, rsize1))\n    return m\n\nwith ContextTimer(\"bench2.1 size={0}\".format(N)):\n    build_bench_model21(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Use batches of constraints\n\nAdding constraints to the model by batches using `Model.add_constraints()`\nis usually more efficient.\nTry grouping consttraints in lists or comprehensions (both work).\n\nIf the constraints are named, pass a second argument with the collection of constraint names.", "apps": [], "results": {"msg": [{"data": "<h2>Use batches of constraints</h2>\n<p></p>\n<p>Adding constraints to the model by batches using <code>Model.add_constraints()</code></p>\n<p>is usually more efficient.</p>\n<p>Try grouping consttraints in lists or comprehensions (both work).</p>\n<p></p>\n<p>If the constraints are named, pass a second argument with the collection of constraint names.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model3(size=10):\n    m = Model(name=\"bench3\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    k = {(i,j) : (i + (i+j) %3) for i in rsize for j in rsize}\n    m.add_constraints((m.scal_prod(ys, [k[i,j] for j in rsize]) >= i for i in rsize),\n                     [\"ct_%d\" % i for i in rsize])\n    # for minimize, create a list of coefficients\n    rsize1 = [i+1 for i in rsize]\n    m.minimize(m.scal_prod(ys, rsize1))\n    return m\n\nwith ContextTimer(\"bench3 size={0}\".format(N)):\n    build_bench_model3(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Avoid creating unnecessary containers\n\nThe previous version allocated one dictionary `k` for coefficients and an auxiliary list for the objective. We can simplify the code bys using comprehensions instead.", "apps": [], "results": {"msg": [{"data": "<h2>Avoid creating unnecessary containers</h2>\n<p></p>\n<p>The previous version allocated one dictionary <code>k</code> for coefficients and an auxiliary list for the objective. We can simplify the code bys using comprehensions instead.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model4(size=10):\n    m = Model(name=\"bench4\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    m.add_constraints((m.scal_prod(ys, [(i+ (i+j)%3) for j in rsize]) >= i for i in rsize),\n                     (\"ct_%d\" % i for i in rsize))\n    # for minimize, create a list of coefficients\n    m.minimize(m.scal_prod(ys, (i+1 for i in rsize)))\n    return m\n\nwith ContextTimer(\"bench4 size={0}\".format(N)):\n    build_bench_model4(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Take control of name generation\n\nNaming variables and/or constraints is useful to generate readable LP files. However, generating lare numbers of strings may have a significant cost in Python, sepcially for large models. \n\nDOcplex provides a keyword `ignore_names` at model creation time, which may disable all names (variables and constraint names alike) that are set in the model. \n\nBy default, this flag is  `False`, and names are enabled. By setting this flag to `True`, all names mentioned in the model are discarded (in particular, names are not used in LP generation).\n\nIn the next version we simply add the `ignore_names=True` keyword argument to the model constructor", "apps": [], "results": {"msg": [{"data": "<h2>Take control of name generation</h2>\n<p></p>\n<p>Naming variables and/or constraints is useful to generate readable LP files. However, generating lare numbers of strings may have a significant cost in Python, sepcially for large models. </p>\n<p></p>\n<p>DOcplex provides a keyword <code>ignore_names</code> at model creation time, which may disable all names (variables and constraint names alike) that are set in the model. </p>\n<p></p>\n<p>By default, this flag is  <code>False</code>, and names are enabled. By setting this flag to <code>True</code>, all names mentioned in the model are discarded (in particular, names are not used in LP generation).</p>\n<p></p>\n<p>In the next version we simply add the <code>ignore_names=True</code> keyword argument to the model constructor</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model5(size=10):\n    m = Model(name=\"bench5\", ignore_names=True)\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    m.add_constraints((m.scal_prod(ys, [(i+ (i+j)%3) for j in rsize]) >= i for i in rsize),\n                     (\"ct_%d\" % i for i in rsize))\n    # for minimize, create a list of coefficients\n    m.minimize(m.scal_prod(ys, (i+1 for i in rsize)))\n    return m\n\nwith ContextTimer(\"bench6 size={0}\".format(N)):\n    build_bench_model5(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Take control of argument checking\n\nDOcplex does a minimal checking on arguments. As this can be useful when writing the model to avoid errors, this checking has a runtime cost. When running a deployed model that has been thoroughly tested and tuned, you can remove all checks by adding the `checker=\"off\"` keyword argument to the model constructor.\n\nAgain, the next version is identical to the previous one , except that type-checking has been disabled.", "apps": [], "results": {"msg": [{"data": "<h2>Take control of argument checking</h2>\n<p></p>\n<p>DOcplex does a minimal checking on arguments. As this can be useful when writing the model to avoid errors, this checking has a runtime cost. When running a deployed model that has been thoroughly tested and tuned, you can remove all checks by adding the <code>checker=\"off\"</code> keyword argument to the model constructor.</p>\n<p></p>\n<p>Again, the next version is identical to the previous one , except that type-checking has been disabled.</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ndef build_bench_model6(size=10):\n    m = Model(name=\"bench6\", ignore_names=True, checker=\"off\")\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    m.add_constraints((m.scal_prod(ys, [(i+ (i+j)%3) for j in rsize]) >= i for i in rsize),\n                     (\"ct_%d\" % i for i in rsize))\n    # for minimize, create a list of coefficients\n    m.minimize(m.scal_prod(ys, (i+1 for i in rsize)))\n    return m\n\nwith ContextTimer(\"bench6 size={0}\".format(N)):\n    build_bench_model6(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Use the \"advanced model\" class\n\nDOcplex contains and `AdvModel` class, which is a subclass of `Model`.\nThis class contains highly efficient methods for special cases, for examples, scalar prodicts with all different variables. \nBy default, `AdvModel` methods do not perform any checking on their arguments. For example, the `cal_prod_vars_all_different` method does not check that the variables are indeed all different. If this is not true, then errors or incorrect results may occur.\n\nStill, you can enable type-checking on AdvModel by specifying `checker=\"on\"` at construction time, and remove it later.\n\nThe benchmark model is a good fit for the `scal_prod_vars_all_different` method as all our scalar products involve the `ys` variables.\n\nAdvModel provides other specialized fast method, among them:\n\n - `sum_vars_all_different` to compute the sum of a sequence of all different variables.\n - `quad_matrix_sum` to compute a quadratic expression from a matrix $Q$ and a vector of variables $X$ as $X^{t}QX$\n - `vector_compare` to compute a sequence of linear constraint from two sequences of expressions\n", "apps": [], "results": {"msg": [{"data": "<h2>Use the \"advanced model\" class</h2>\n<p></p>\n<p>DOcplex contains and <code>AdvModel</code> class, which is a subclass of <code>Model</code>.</p>\n<p>This class contains highly efficient methods for special cases, for examples, scalar prodicts with all different variables. </p>\n<p>By default, <code>AdvModel</code> methods do not perform any checking on their arguments. For example, the <code>cal_prod_vars_all_different</code> method does not check that the variables are indeed all different. If this is not true, then errors or incorrect results may occur.</p>\n<p></p>\n<p>Still, you can enable type-checking on AdvModel by specifying <code>checker=\"on\"</code> at construction time, and remove it later.</p>\n<p></p>\n<p>The benchmark model is a good fit for the <code>scal_prod_vars_all_different</code> method as all our scalar products involve the <code>ys</code> variables.</p>\n<p></p>\n<p>AdvModel provides other specialized fast method, among them:</p>\n<p></p>\n<ul>\n<li><code>sum_vars_all_different</code> to compute the sum of a sequence of all different variables.</li>\n</ul>\n<ul>\n<li><code>quad_matrix_sum</code> to compute a quadratic expression from a matrix $Q$ and a vector of variables $X$ as $X^{t}QX$</li>\n</ul>\n<ul>\n<li><code>vector_compare</code> to compute a sequence of linear constraint from two sequences of expressions</li>\n</ul>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\nfrom docplex.mp.advmodel import AdvModel\n\ndef build_bench_model7(size=10):\n    m = AdvModel(name=\"bench7\", ignore_names=True, checker='off')\n    rsize = range(size)\n    # create variables as a dictionary indexed by the range\n    ys = m.binary_var_list(rsize, name=\"y\")\n    # create constraints\n    m.add_constraints((m.scal_prod_vars_all_different(ys, [(i+ (i+j)%3) for j in rsize]) >= i for i in rsize),\n                 (\"ct_%d\" % i for i in rsize))\n    \n    # for minimize, use comprehension\n    m.minimize(m.scal_prod_vars_all_different(ys, (i+1 for i in rsize)))\n    return m\n\nwith ContextTimer(\"bench7 size={0}\".format(N)):\n    build_bench_model7(N)", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n# Summary\n\nFrom version 1 to version 7 , model build time has decreased from 35s to 4s (on our platform). Result smay well differ on other platforms, but still, this demonstrates that the way the model is built can greatly influence the performance.\n\nHere is a list of tricks to try to improve model building time:\n\n - Use Model.scal_prod wherever possible\n - Add constraints in batches, not one by one\n - Leverage Python comprehensions to avoid unnecessary data structures\n - Try ignoring name generation (for large models)\n - Try disabling all argument checking\n - Eventually, look at specialized methods in the `AdvModel` class.", "apps": [], "results": {"msg": [{"data": "<h1>Summary</h1>\n<p></p>\n<p>From version 1 to version 7 , model build time has decreased from 35s to 4s (on our platform). Result smay well differ on other platforms, but still, this demonstrates that the way the model is built can greatly influence the performance.</p>\n<p></p>\n<p>Here is a list of tricks to try to improve model building time:</p>\n<p></p>\n<ul>\n<li>Use Model.scal_prod wherever possible</li>\n</ul>\n<ul>\n<li>Add constraints in batches, not one by one</li>\n</ul>\n<ul>\n<li>Leverage Python comprehensions to avoid unnecessary data structures</li>\n</ul>\n<ul>\n<li>Try ignoring name generation (for large models)</li>\n</ul>\n<ul>\n<li>Try disabling all argument checking</li>\n</ul>\n<ul>\n<li>Eventually, look at specialized methods in the <code>AdvModel</code> class.</li>\n</ul>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Plotting the trend\n\nIn this section we compute the times to build different model versions on various sizes, and\nplot the result on a graph.\nThis code requires the `matplotlib` library to run.\n\n**Note**: the next cell might take a significant time to run, as it\nruns a lot of (size, model_build_function) combinations...", "apps": [], "results": {"msg": [{"data": "<h2>Plotting the trend</h2>\n<p></p>\n<p>In this section we compute the times to build different model versions on various sizes, and</p>\n<p>plot the result on a graph.</p>\n<p>This code requires the <code>matplotlib</code> library to run.</p>\n<p></p>\n<p><strong>Note</strong>: the next cell might take a significant time to run, as it</p>\n<p>runs a lot of (size, model<em>build</em>function) combinations...</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\n# various sizes to sample performance\nsizes = [100, 300, 600, 1000, 3000, 5000]\n\n# a lits of tuples (fn, label) to build model and an explanatory label\nbuilders = [(build_bench_model1, \"initial\"), \n            (build_bench_model2, \"scal_prod\"),\n            (build_bench_model4, \"batch_cts\"),\n            (build_bench_model5, \"ignore_names\"),\n            (build_bench_model6, \"checker_off\"),\n            (build_bench_model7, \"advmodel\")]\nprint(\"* start computing performance data\")\nres = {}\nprint(\"* start computing results...\")\nnb_runs = len(sizes) * len(builders)\nr = 0\nfor s in sizes:\n    for b, (bf, _) in enumerate(builders):\n        r +=1 \n        with ContextTimer(\"[{2}/{3}] use {0} with size={1}\"\n                          .format(bf.__name__, s, r, nb_runs)) as tt:\n            m = bf(s)\n            m.end()\n        elapsed = tt.msecs\n        res[b, s] = tt.msecs\n\n\nprint(\"* end computing results\")\n# now we have a dict of (#builder, size) -> time", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\ntry:\n    import matplotlib.pyplot as plt\n    except ImportError:\n    print(\"try install matplotlib: pip install matplotlib\")\n    raise\n\n\nlabels = [ bl for (_, bl) in builders]\nplt.figure(figsize=(16,7))\nfor b in range(len(builders)):\n    bts = [res[b,s]/1000 for s in sizes]\n    plt.plot(sizes, bts, label=labels[b])\n    plt.legend()\n\nplt.show()", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%md\n## Average improvement\n\nIn the next cell, we compute the geometric mean of improvment between the first and last versions. Of course, results may differ depending on platform (and the model, too) but the idea is, applying the above rules may yield a significant improvement", "apps": [], "results": {"msg": [{"data": "<h2>Average improvement</h2>\n<p></p>\n<p>In the next cell, we compute the geometric mean of improvment between the first and last versions. Of course, results may differ depending on platform (and the model, too) but the idea is, applying the above rules may yield a significant improvement</p>\n", "type": "HTML"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": true, "language": "markdown"}, "editorMode": "ace/mode/markdown", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\n# compute geomerical mean for all sizes\nnb_builders = len(builders)\nratios = {}\nfor s in sizes:\n    initial = res[0, s]\n    final = res[nb_builders-1, s]\n    r = (initial/final)\n    ratios[s] = r\n\nimport math\nrgm = math.exp(sum(math.log(r) for r in ratios.values()) / float(nb_builders))\nprint(\"* geometric mean of time improvement is {0:.1f}\".format(rgm))", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}, {"settings": {"forms": {}, "params": {}}, "text": "%python\n", "apps": [], "results": {"msg": [{"data": "", "type": "ANGULAR"}], "code": "SUCCESS"}, "user": "anonymous", "config": {"editorSetting": {"editOnDblClick": false, "language": "python"}, "editorMode": "ace/mode/python", "colWidth": 12, "enabled": true, "results": {}}}]}